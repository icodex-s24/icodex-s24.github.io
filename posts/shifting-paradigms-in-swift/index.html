<!doctype html><html lang="en" data-mode="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7" /><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e" /><meta name="apple-mobile-web-app-capable" content="yes" /><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" /><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Shifting paradigms in Swift" /><meta property="og:locale" content="en" /><meta name="description" content="Every year during WWDC, we in the Apple developer community are presented with a whole suite of new tools, APIs and technologies that we can use to further improve our apps along with the systems that they run on. While most of those changes tend to be quite slow and steady - a sort of natural evolution happening over a long period of time - this year, things have turned out a bit different." /><meta property="og:description" content="Every year during WWDC, we in the Apple developer community are presented with a whole suite of new tools, APIs and technologies that we can use to further improve our apps along with the systems that they run on. While most of those changes tend to be quite slow and steady - a sort of natural evolution happening over a long period of time - this year, things have turned out a bit different." /><link rel="canonical" href="/posts/shifting-paradigms-in-swift/" /><meta property="og:url" content="/posts/shifting-paradigms-in-swift/" /><meta property="og:site_name" content="iCodeX’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-01-16T17:02:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Shifting paradigms in Swift" /><meta name="twitter:site" content="@icodex-s24" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-01-16T17:02:00-05:00","datePublished":"2019-01-16T17:02:00-05:00","description":"Every year during WWDC, we in the Apple developer community are presented with a whole suite of new tools, APIs and technologies that we can use to further improve our apps along with the systems that they run on. While most of those changes tend to be quite slow and steady - a sort of natural evolution happening over a long period of time - this year, things have turned out a bit different.","headline":"Shifting paradigms in Swift","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/shifting-paradigms-in-swift/"},"url":"/posts/shifting-paradigms-in-swift/"}</script><title>Shifting paradigms in Swift | iCodeX's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="iCodeX's blog"><meta name="application-name" content="iCodeX's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css" /><link rel="stylesheet" href="/assets/lib/fonts/main.css" /><link rel="stylesheet" href="/assets/lib/fontawesome-free/css/all.min.css" /><link rel="stylesheet" href="/assets/lib/tocbot/tocbot.min.css" /><link rel="stylesheet" href="/assets/lib/loading-attribute-polyfill/loading-attribute-polyfill.min.css" /><link rel="stylesheet" href="/assets/lib/glightbox/glightbox.min.css" /><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/logo.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a><h1 class="site-title"> <a href="/">iCodeX's blog</a></h1><p class="site-subtitle fst-italic mb-0">Code. Learn. Write. Repeat</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/icodex-s24" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/icodex-s24" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['j.doit926','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Shifting paradigms in Swift</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>Shifting paradigms in Swift</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1547676120" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jan 16, 2019 </time> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/icodex-s24">icodex-s24</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="1651 words" > <em>9 min</em> read</span></div></div></div></header><div class="content"><p>Every year during WWDC, we in the Apple developer community are presented with a whole suite of new tools, APIs and technologies that we can use to further improve our apps along with the systems that they run on. While most of those changes tend to be quite slow and steady - a sort of natural evolution happening over a long period of time - this year, things have turned out a bit different.</p><p>The introduction of technologies like SwiftUI (Apple’s new declarative UI framework), Catalyst(iOS apps running on the Mac), and Combine (a built in “Rx-like” reactive data library) might very well be considered the beginning of a “new era” of app development for Apple’s platform. That might sound a bit hyperbolic - but I think it’s fair to say that Apple haven’t attempted to make this big of a leap when it comes to their developer tools since the introduction of Swift in 2014.</p><p>So what does that mean for us third party developers, and how can we prepare ourselves for undergoing a major paradigm shift over the next few years - as we move from imperative to declarative, from Objective-C to Swift, and from delegates to subscribers?</p><h2 id="gradual-adoption-gradual-mastery"><span class="me-2">Gradual adoption, gradual mastery</span><a href="#gradual-adoption-gradual-mastery" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>When presented with any kind of technological transition - whether that’s from frame-based layouts to Auto Layout, from 32-bit to 64-bit apps, or from UIkit to SwiftUI - it can be tempting to use that transition as an opportunity to start over from a completely clean slate. Out with the old legacy code, and in with the beautiful,shiny new APIs.</p><p><em>“We rewrote our app from the ground up”</em> is something that you often hear companies of all sizes proudly announce in blog posts, conference talks, and even in customer-facing marketing - and both developers and customers alike often get genuinely excited when hearing sentences like that. It makes an app update seem like something fresh and brand new, rather than just an incremental upgrade.</p><p>However, while full rewrites do have their metrics - and might be warranted if a code base has truly gone beyond the point of on return - they often turn out to be way less appealing in practice then they are in theory, as old bugs are replaced by new bugs, and various subtitles and handling of edge cases are missed when writing the new implementation.</p><p>Especially when undergoing major paradigm shifts, gradual adoption instead lets us ease into using all of the new technologies, pattern and tools that have just been introduced - in a way that both lets us keep leveraging our existing code base, and lets us keeping shipping our app to our users on a regular basis.</p><p>Gradually adopting new technologies also lets us dip our toes in the water before completely diving in - giving us a way to gradually master the new APIs and conventions as we’re starting to use them. After all, there’s no real rush when it comes to adopting new tools and frameworks - it’s not like the existing frameworks and code that we’ve been shipping will stop working overnight.</p><h2 id="mix-and-match"><span class="me-2">Mix and match</span><a href="#mix-and-match" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>While gradual adoption might sound great on paper, actually getting it done in practice can be much less straightforward. The key is often to find a nice way to “mix and match” our existing code and functionality with the new code and patterns that we’re introducing.</p><p>As an example, when it comes to new framework like SwiftUI, Apple has - thankfully - already considered this, and is offering full interoperability between SwiftUI and UIKit. So if we wanted to start easing our way into adopting SwiftUI, by building a single screen using it - say a view for rendering in app promotions - then we could do so by wrapping our new SwiftUI <code class="language-plaintext highlighter-rouge">PromotionView</code> in an instance of <code class="language-plaintext highlighter-rouge">UIHostingController</code>, like this:</p><div class="language-swift highlighter-rouge"><div class="code-header"> <span data-label-text="Swift"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">vc</span> <span class="o">=</span> <span class="kt">UIHostingController</span><span class="p">(</span><span class="nv">rootView</span><span class="p">:</span> <span class="kt">PromotionView</span><span class="p">())</span>
</pre></table></code></div></div><p>Since <code class="language-plaintext highlighter-rouge">UIHostingController</code> is just a regular UIKit view controller - it can be presented, embedded as a child, or pushed onto a navigation controller - all while being powered by SwiftUI under the hood.</p><p>When a framework has a clear backward compatibility story, that’s most often a great sign - as it shows that the authors didn’t only focus on building a great new set of tools, but also on how those tools will be integrated into existing projects, which usually makes for much more complete API.</p><p>Even better is when new tools and frameworks don’t only offer backward compatibility, but forward compatibility as well. Again using SwiftUI as an example, an <code class="language-plaintext highlighter-rouge">UIView</code> can quite easily be made SwiftUI-compatible, by wrapping it in an implementation of the <code class="language-plaintext highlighter-rouge">UIViewPresentable</code> protocol. Here’s an example that wraps an existing <code class="language-plaintext highlighter-rouge">ProfileView</code>, which is a <code class="language-plaintext highlighter-rouge">UIView</code> subclass used to render a user’s profile:</p><div class="language-swift highlighter-rouge"><div class="code-header"> <span data-label-text="Swift"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">struct</span> <span class="kt">ProfileSwiftUIView</span><span class="p">:</span> <span class="kt">UIViewPresentable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">user</span><span class="p">:</span> <span class="kt">User</span>

    <span class="kd">func</span> <span class="nf">makeUIView</span><span class="p">(</span><span class="nv">context</span><span class="p">:</span> <span class="kt">Context</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ProfileView</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">ProfileView</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">updateUIView</span><span class="p">(</span><span class="n">_</span> <span class="nv">view</span><span class="p">:</span> <span class="kt">ProfileView</span><span class="p">,</span> <span class="nv">context</span><span class="p">:</span> <span class="kt">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">view</span><span class="o">.</span><span class="n">nameLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span>
        <span class="n">view</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">image</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Both of the above two techniques are clear example of how new developer paradigms - like SwiftUI - can be implemented piece by piece, rather than through full rewrites, given that the right tooling has been put in place. Gradual adoption isn’t always possible, but when it is, it lets us both use new technologies to build new features - while still making full use of our existing code as well - kind of giving us the best of both worlds.</p><h2 id="parallel-implementation"><span class="me-2">Parallel implementation</span><a href="#parallel-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Since paradigm shifts usually take place over quite a long period of time(years often), simply being able to build new features using new tools an APIs isn’t always enough. We might not be prepared to drop support for old OS versions, or we might not be completely confident that a certain new tool is the right fit for what we’re trying to build.</p><p>In both of those cases, using multiple, parallel implementations of the same feature can be an option. While it’s an option that certainly has a cost, it does give us a ton of additional flexibility - as we can start replacing the implementation details of a given feature using new technologies, all without either abandoning existing users, existing code.</p><p>Let’s take a look at how that could be done in practice, again using SwiftUI as an example. Say we wanted to start experimenting with using SwiftUI to build one of our app’s features - to learn it, and to figure out how our code base could best make use of it - while still keep shipping our UIKit-based implementation, for now.</p><p>To do that, we could use the <em>factory pattern</em> to create an abstraction that hides which UI framework that’s currently used to implement our feature - an article reading screen in this case:</p><div class="language-swift highlighter-rouge"><div class="code-header"> <span data-label-text="Swift"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">protocol</span> <span class="kt">ArticleViewControllerFactory</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">makeViewController</span><span class="p">(</span><span class="k">for</span> <span class="nv">article</span><span class="p">:</span> <span class="kt">Article</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UIViewController</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Using the above protocol , we could now easily change which UI framework that our feature will use, without changing any other part of our code base. We could start by wrapping our existing UIKit-based <code class="language-plaintext highlighter-rouge">ArticleViewController</code> in a factory that simply creates ne instance of it, by passing in its required dependencies - like this:</p><div class="language-swift highlighter-rouge"><div class="code-header"> <span data-label-text="Swift"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">struct</span> <span class="kt">ArticleUIKitViewControllerFactory</span><span class="p">:</span> <span class="kt">ArticleViewControllerFactory</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">navigator</span><span class="p">:</span> <span class="kt">ArticleNavigator</span>
    <span class="k">let</span> <span class="nv">imageLoader</span><span class="p">:</span> <span class="kt">ImageLoader</span>

    <span class="kd">func</span> <span class="nf">makeViewController</span><span class="p">(</span><span class="k">for</span> <span class="nv">article</span><span class="p">:</span> <span class="kt">Article</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UIViewController</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">ArticleViewController</span><span class="p">(</span>
            <span class="nv">article</span><span class="p">:</span> <span class="n">article</span><span class="p">,</span> 
            <span class="nv">navigator</span><span class="p">:</span> <span class="n">navigator</span><span class="p">,</span>
            <span class="nv">imageLoader</span><span class="p">:</span> <span class="n">imageLoader</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Similarly, we could create another <code class="language-plaintext highlighter-rouge">ArticleViewControllerFactory</code> implementation that instead creates an instance of our SwiftUI-based <code class="language-plaintext highlighter-rouge">ArticleView</code> - and then wraps that in a <code class="language-plaintext highlighter-rouge">UIHostingController</code>, which is then returned. To be able to keeping shipping our app to users using iOS 12 and below, we’ll also mark this factory implementation as being only available on iOS 13:</p><div class="language-swift highlighter-rouge"><div class="code-header"> <span data-label-text="Swift"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">@available</span><span class="p">(</span><span class="n">iOS</span> <span class="mi">13</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span>
<span class="kd">struct</span> <span class="kt">ArticleSwiftUIViewControllerFactory</span><span class="p">:</span> <span class="kt">ArticleViewControllerFactory</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">navigator</span><span class="p">:</span> <span class="kt">ArticleNavigator</span>
    <span class="k">let</span> <span class="nv">imageLoader</span><span class="p">:</span> <span class="kt">ImageLoader</span>

    <span class="kd">func</span> <span class="nf">makeViewController</span><span class="p">(</span><span class="k">for</span> <span class="nv">article</span><span class="p">:</span> <span class="kt">Article</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UIViewController</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">view</span> <span class="o">=</span> <span class="kt">ArticleView</span><span class="p">(</span>
            <span class="nv">navigator</span><span class="p">:</span> <span class="n">navigator</span><span class="p">,</span>
            <span class="nv">imageLoader</span><span class="p">:</span> <span class="n">imageLoader</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kt">UIHostingController</span><span class="p">(</span><span class="nv">rootVie</span><span class="p">:</span> <span class="n">view</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>With the above in place, we’d now be able to select which implementation to use based on any number of conditions - for example whether the device we’re targeting is already running on iOS 13, and whether we’ve enable a custom <code class="language-plaintext highlighter-rouge">USE_SWIFT_UI</code> compiler flag:</p><div class="language-swift highlighter-rouge"><div class="code-header"> <span data-label-text="Swift"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">articleViewControllerFactory</span><span class="p">:</span> <span class="kt">ArticleViewControllerFactory</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cp">#if USE_SWIFT_UI</span>
    <span class="k">if</span> <span class="k">#available</span><span class="p">(</span><span class="n">iOS</span> <span class="mi">13</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">ArticleSwiftUIViewControllerFactory</span><span class="p">(</span>
            <span class="nv">navigator</span><span class="p">:</span> <span class="n">navigator</span><span class="p">,</span>
            <span class="nv">imageLoader</span><span class="p">:</span> <span class="n">imageLoader</span>
        <span class="p">)</span>
    <span class="p">}</span>
    <span class="cp">#endif</span>

    <span class="k">return</span> <span class="kt">ArticleUIKitViewControllerFactory</span><span class="p">(</span>
        <span class="nv">navigator</span><span class="p">:</span> <span class="n">navigator</span><span class="p">,</span>
        <span class="nv">imageLoader</span><span class="p">:</span> <span class="n">imageLoader</span>
    <span class="p">)</span>
<span class="p">}()</span>
</pre></table></code></div></div><p>Doing something like the above may seem like a lot of unnecessary extra work (why maintain two implementations of the same feature, when we can just have one?) - but it does give us a ton of extra flexibility - and a way to start easing into a new paradigm (and giving us a <em>“safe place”</em> to learn all of its new patterns) while still being able to keep shipping our existing code, just like before.</p><p>The above approach can also be a great way to improve the overall architecture and separation of concerns within a code base, since we’d have to make sure that our core services - like <code class="language-plaintext highlighter-rouge">ArticleNavigator</code> and <code class="language-plaintext highlighter-rouge">ImageLoader</code> in this example - are completely separated from our UI code, which usually makes for an overall clear structure and easier testing.</p><h2 id="conclusion"><span class="me-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Big paradigm shifts can both be incredibly exciting, but also confusing, and a bit scary. While it’s very common to get the feeling that the introduction of major new APIs and technologies suddenly turned all of our existing code into <em>“tech debt”</em> - that’s rarely the case, and there’s often a way to be found that lets us keep leveraging our existing code’s functionality, while also starting to adopt and learn the new paradigm’s technologies and patterns.</p><p>Thanks for reading!</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/swiftui/">SwiftUI</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/swiftui/" class="post-tag no-text-decoration" >swiftui</a> <a href="/tags/architecture/" class="post-tag no-text-decoration" >architecture</a> <a href="/tags/swift5-0/" class="post-tag no-text-decoration" >swift5.0</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Shifting%20paradigms%20in%20Swift%20-%20iCodeX's%20blog&url=%2Fposts%2Fshifting-paradigms-in-swift%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Shifting%20paradigms%20in%20Swift%20-%20iCodeX's%20blog&u=%2Fposts%2Fshifting-paradigms-in-swift%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fshifting-paradigms-in-swift%2F&text=Shifting%20paradigms%20in%20Swift%20-%20iCodeX's%20blog" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/conditioning-habits/">Conditioning Habits - The Key to Lasting Change</a><li class="text-truncate lh-lg"> <a href="/posts/cover-6mn-study-in-3days/">Cramming Effectively - How to Cover 6 Months of Study in 72 Hours</a><li class="text-truncate lh-lg"> <a href="/posts/comparison-human-brain-supercomputer/">Human Brain vs. Supercomputer - A Hardware Perspective</a><li class="text-truncate lh-lg"> <a href="/posts/power-detachment/">The Power of Detachment - A Key to Better Decision-Making and Leadership</a><li class="text-truncate lh-lg"> <a href="/posts/how-use-docker-windows-offline/">Building a Docker Environment Completely Offline on Windows 10</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/basics/">basics</a> <a class="post-tag btn btn-outline-primary" href="/tags/llm/">llm</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">ai</a> <a class="post-tag btn btn-outline-primary" href="/tags/swiftui/">swiftui</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/learning/">learning</a> <a class="post-tag btn btn-outline-primary" href="/tags/habits/">habits</a> <a class="post-tag btn btn-outline-primary" href="/tags/strategy/">strategy</a> <a class="post-tag btn btn-outline-primary" href="/tags/swift5-0/">swift5.0</a> <a class="post-tag btn btn-outline-primary" href="/tags/swift5-1/">swift5.1</a></div></section></div><section id="toc-wrapper" class="d-none ps-0 pe-4"><h2 class="panel-heading ps-3 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/feature-flags-in-swift/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1522015320" data-df="ll" > Mar 25, 2018 </time><h4 class="pt-0 my-2">Feature flags in Swift</h4><div class="text-muted"><p>When developing new features for an app, it can be really useful to have some form of mechanism to gradually roll out new implementation &amp;amp; functionality, instead of having to launch to every si...</p></div></div></a></article><article class="col"> <a href="/posts/understanding-riscv-and-manufacture/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1725430522" data-df="ll" > Sep 4, 2024 </time><h4 class="pt-0 my-2">Understanding RISC-V and Manufacture</h4><div class="text-muted"><p>Jim Keller, a prominent figure in CPU design, has been vocal about the potential of RISC-V architecture, especially in comparison to proprietary architectures like Apple’s Silicon. Here’s an overvi...</p></div></div></a></article><article class="col"> <a href="/posts/comparision-arm64-amd64/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1725429283" data-df="ll" > Sep 4, 2024 </time><h4 class="pt-0 my-2">comparision-arm64-amd64</h4><div class="text-muted"><p>The comparison between AArch64 (also known as ARM64) and AMD64 (also referred to as x86-64) highlights significant differences in architecture, design philosophy, and application use cases. Here’s ...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/swiftui-stacking-views/" class="btn btn-outline-primary" aria-label="Older" ><p>Stacking views in SwiftUI</p></a> <a href="/posts/swiftui-refactoring-view-using-functions/" class="btn btn-outline-primary" aria-label="Newer" ><p>Refactoring SwiftUI views using functions</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/icodex-s24">icodex-s24</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.1.0" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/basics/">basics</a> <a class="post-tag btn btn-outline-primary" href="/tags/llm/">llm</a> <a class="post-tag btn btn-outline-primary" href="/tags/ai/">ai</a> <a class="post-tag btn btn-outline-primary" href="/tags/swiftui/">swiftui</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">architecture</a> <a class="post-tag btn btn-outline-primary" href="/tags/learning/">learning</a> <a class="post-tag btn btn-outline-primary" href="/tags/habits/">habits</a> <a class="post-tag btn btn-outline-primary" href="/tags/strategy/">strategy</a> <a class="post-tag btn btn-outline-primary" href="/tags/swift5-0/">swift5.0</a> <a class="post-tag btn btn-outline-primary" href="/tags/swift5-1/">swift5.1</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="/assets/lib/simple-jekyll-search/simple-jekyll-search.min.js"></script> <script src="/assets/lib/loading-attribute-polyfill/loading-attribute-polyfill.umd.min.js"></script> <script src="/assets/lib/glightbox/glightbox.min.js"></script> <script src="/assets/lib/clipboard/clipboard.min.js"></script> <script src="/assets/lib/dayjs/dayjs.min.js"></script> <script src="/assets/lib/dayjs/locale/en.js"></script> <script src="/assets/lib/dayjs/plugin/relativeTime.js"></script> <script src="/assets/lib/dayjs/plugin/localizedFormat.js"></script> <script src="/assets/lib/tocbot/tocbot.min.js"></script> <script src="/assets/js/dist/post.min.js"></script> <script defer src="/app.min.js"></script> <script>SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
